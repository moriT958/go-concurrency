# goroutines

- Go のランタイムに管理される軽量なスレッド。
- 前提知識
- プロセスとは？：実行中プログラムのインスタンス。OS によって生成され、コード、データ、ファイルハンドル、スタック、ヒープメモリを含む。他のプロセスとはメモリ空間を共有せず、独立している。
- スレッドとは？：プロセス内で実行される軽量な実行単位。1 プロセスに複数のスレッドが存在可能(マルチスレッド)。各スレッドは同じメモリ空間を共有し、独自のスタックを持つ。
- 並行処理とは？：複数のタスクに対して、CPU が高速でタスクの切り替えを行うことで、同時にタスクが処理されているように見せる方法。
- 並列処理とは？：CPU が複数のコアやプロセッサを持つ場合、物理的にタスクを割り当て、同時に処理を行う方法。GPU などを使うこともできる。
- 一般的に並列処理を扱うものとして、コルーチン(coroutines)があり、goroutines もその一種。

- main 関数で実行される処理も goroutine であり、他の goroutine の基準点となる。
- goroutines は fork-join モデルを採用しており、親ルーティンから子ルーティンをフォーク(分岐)させ、処理が終わると親ルーティンにジョイン(合流)するようになっている。
- 実行する関数の前に go キーワードを付けるだけでその処理をフォークさせることができる。

- 親ルーティンが先に処理を終えてしまうと、子ルーティンとの合流ポイントが消えてしまうため、子ルーティンが実行されない可能性がある。
- sync.WaitGroup パッケージなどを使用して、親ルーティンに合流ポイント作成しておくのが確実。

# 並行処理と並列処理

- 並行処理(Concurrency)
  　ある時間の範囲において、複数のスレッドを扱うこと。

- 並列処理(Parallelism)
  　ある時間の点において、複数のスレッドを扱うこと

Go 公式ブログ"Concurrency is not parallelism"では以下のように述べられている。  
「プログラミングにおいて、並列処理は(関連する可能性のある)処理を同時に実行することであるのに対し、並行処理はプロセスをそれぞれ独立に実行できるような構成のことを指します。
並行処理は一度に多くのことを「扱う」ことであり、並列処理は一度に多くのことを「行う」ことです。」

- ハードかソフトかの観点での違い
  　並行処理は、問題解決の手段としてのプログラミングパターンのこと。並列処理は、並行処理を可能にするハードウェアの特性のことです。
  また、並行性はコードの性質を指し、並列性は動作しているプログラムの性質を指します。

- 以下のように言える
  「ユーザーは並列なコードを書いているのではなく、並列に走ってほしいと思う並行なコードを書いている」
  「並行なコードが、実際に並列に走っているかどうかは知らなくていい」

Go 言語で作れるのは「コード/ソフトウェア」であり、前述した通りそれらの性質を指し示すのは「並行性」のほうです。

# ゴルーチンとチャネル

go 文は渡された関数を、同じアドレス空間中で独立した並行スレッド(ゴールーチン)の中で実行します。

新しく立ち上げたゴルーチンの実行が終わるまでメインゴルーチンが待つ必要がある場合は、sync パッケージの WaitGroup を使う。

チャネルは、特定の型の値を送信・受信することで(異なるゴールーチンで)並行に実行している関数がやり取りする機構を提供している。
異なるゴールーチン同士が、特定の型の値を送受信することでやりとりする機構。

チャネルを立ち上げた場合、そのゴルーチンは作成したチャネルから値を受け取るまでブロックされるため、待ち合わせを行う必要はない。
ブロック=>何かしらの原因でスレッド(ゴルーチン)の実行が進まなくなること。DB のデッドロックのような状態。

# Go 並列処理基礎

## チャネルの状態

1. nil かどうか
2. closed かどうか
3. バッファが空いているか(バッファに値があるか)
4. 送信/受信専用かどうか

## チャネルに対する操作

1. 値の受信
2. 値の送信
3. クローズ操作

## チャネルの状態と操作の関係

![](https://storage.googleapis.com/zenn-user-upload/2ecc11e5f2ad8dd9ab62c3f4.png)

- nil チャネルへの値の送受信を行うと、送受信を行なったゴルーチンはブロックされる。

以上より以下のことが言える。  
　チャネルを通して、値を送信するゴルーチンとそれを受け取るゴルーチンがあるとする。
受信側のゴルーチンの準備が整うまで、送信側はブロックされたようにチャネルによって制御される。
このことから、チャネルは WaitGroup のような、実行同期のための機構でもある。

※ Goの参照型について
 Goのスライス型、マップ型、ポインタ型、チャネル型が当てはまる。

参照型を使ったゴルーチンを使用する時は、ゴルーチンが参照する値がその時々によって変わってしまう可能性があるので注意。
例えばappend関数をゴルーチンの中で使用する際など。
appnedは第一引数で受け取ったスライスの番地を参照し、第二引数の値を追加した新たなスライスを返す。
そのため、参照型の値のやり取りではチャネルを活用する。もしくは、参照するスライスに排他制御を行うこともできる。(sync.Mutex)

- closeされたチャネルから値を受信しようとすると、ゼロ値のnilが返ってくる。
返ってきたnilが、値として返ってきたものなのか、closedチャネルのゼロ値として返ってきたのかを判断するには、第2引数を見る。
`val, ok := chan`このokはチャネルから受信した場合はtrue、そうでない場合はfalseが入る。